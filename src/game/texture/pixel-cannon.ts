import Phaser from "phaser";
// Assuming GameScene is your main scene class, adjust if needed
// import GameScene from './GameScene';

export interface PixelCannonColors {
  base: number; // Main body color (e.g., 0x888888 - grey)
  shadow: number; // Darker color for depth/outline (e.g., 0x444444)
  highlight: number; // Lighter color for the top edge (e.g., 0xcccccc)
}

/**
 * Creates a pixel-art style cannon texture programmatically.
 * Draws onto a small internal canvas and generates a texture.
 * The resulting texture should be scaled up when used on a Sprite.
 *
 * @param gameScene The Phaser Scene instance.
 * @param key The unique key to assign to the generated texture.
 * @param colors An object containing hex color values for different parts.
 * @param pixelWidth The desired width of the cannon *in pixels* (small value, e.g., 24).
 * @param pixelHeight The desired height of the cannon *in pixels* (small value, e.g., 12).
 */
export function createPixelCannonTexture(
  gameScene: Phaser.Scene, // Use Phaser.Scene for broader compatibility
  key: string,
  colors: PixelCannonColors,
  pixelWidth: number, // e.g., 24
  pixelHeight: number, // e.g., 12 (should be even for radius calc)
): void {
  // Returns void as it adds texture to cache

  // 1. Create temporary Graphics object
  // Important: Use integer coordinates for pixel art
  const graphics = gameScene.make.graphics({}, false);

  // --- Draw Layers (Bottom to Top) ---

  // A. Shadow/Outline Layer (Optional but adds depth)
  // Draw the full shape slightly offset (e.g., 1 pixel down)
  graphics.fillStyle(colors.shadow, 1);
  const shadowPoints: Phaser.Math.Vector2[] = calculateCannonPoints(pixelWidth, pixelHeight, 1);
  graphics.fillPoints(shadowPoints, true);

  // B. Base Color Layer
  graphics.fillStyle(colors.base, 1);
  const basePoints: Phaser.Math.Vector2[] = calculateCannonPoints(
    pixelWidth,
    pixelHeight,
    0, // No offset
  );
  graphics.fillPoints(basePoints, true);

  // C. Highlight Layer
  // Draw a simple rectangle along the top edge of the barrel/arc
  graphics.fillStyle(colors.highlight, 1);
  const highlightHeight = Math.max(1, Math.floor(pixelHeight * 0.15)); // ~1-2 pixels high
  // Start slightly into the arc, end at the barrel end
  graphics.fillRect(
    pixelHeight, // Start partway into the arc
    0, // At the top
    pixelWidth - pixelHeight - 1, // Leave 1px margin at the end
    highlightHeight,
  );

  // 5. Generate the texture FROM THE SMALL DRAWING
  graphics.generateTexture(key, pixelWidth, pixelHeight);

  // 6. Clean up
  graphics.destroy();
}

/**
 * Helper function to calculate the points for the cannon shape polygon.
 * Separated for clarity, used by base and shadow layers.
 */
function calculateCannonPoints(
  width: number,
  height: number,
  _offsetY: number, // Vertical offset for shadow
): Phaser.Math.Vector2[] {
  const radius = height / 2;
  const circleCenterX = radius;
  const circleCenterY = radius;

  // Calculate rectangle position relative to the circle center
  const rectX = circleCenterX;
  const rectY = circleCenterY - radius;
  const rectWidth = width - radius;
  const rectHeight = height;

  // 3. Define the points of the combined shape polygon
  const points: Phaser.Math.Vector2[] = [];

  // --- Start with rectangle corners (excluding the left edge) ---
  // Top-right corner
  points.push(new Phaser.Math.Vector2(rectX + rectWidth, rectY));
  // Bottom-right corner
  points.push(new Phaser.Math.Vector2(rectX + rectWidth, rectY + rectHeight));

  // --- Add points along the semicircle arc ---
  // Go from bottom tangent point counter-clockwise to top tangent point
  const arcPointsCount = 10; // Number of segments on the arc
  const startAngle = Phaser.Math.DegToRad(90); // Bottom (Y increases down)
  // Total angle sweep is 180 degrees counter-clockwise (PI radians)
  const angleStep = Math.PI / arcPointsCount;

  for (let i = 0; i <= arcPointsCount; i++) {
    // Calculate the angle for this point on the arc
    // Start at 90 deg and add steps counter-clockwise
    const currentAngle = startAngle + i * angleStep;

    const px = circleCenterX + radius * Math.cos(currentAngle);
    const py = circleCenterY + radius * Math.sin(currentAngle);
    points.push(new Phaser.Math.Vector2(px, py));
  }

  // The loop automatically includes the start (bottom) and end (top) tangent points.
  // The final point generated by the loop (i=arcPointsCount) should be the top-left
  // corner of the rectangle / top tangent of the circle.

  return points;
}
